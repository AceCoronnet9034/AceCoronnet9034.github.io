<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>任务栏全透明及隐藏系统托盘图标</title>
      <link href="2020/12/08/ren-wu-lan-quan-tou-ming-ji-yin-cang-xi-tong-tuo-pan-tu-biao/"/>
      <url>2020/12/08/ren-wu-lan-quan-tou-ming-ji-yin-cang-xi-tong-tuo-pan-tu-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="任务栏全透明"><a href="#任务栏全透明" class="headerlink" title="任务栏全透明"></a>任务栏全透明</h1><p>现微软不提供任务栏全透明</p><h4 id="不借助软件可实现半透明，实现步骤"><a href="#不借助软件可实现半透明，实现步骤" class="headerlink" title="不借助软件可实现半透明，实现步骤"></a>不借助软件可实现半透明，实现步骤</h4><p>在任务栏设置-任务栏透明 打开</p><p>win+r输入regedit打开注册表<br>在上面搜索栏直接输入HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced即可直接定位，按照这个顺序逐级点开也可以。<br>在右侧新建一个DWORD(32位)值，命名为UseOLEDTaskbarTransparency<br>双击UseOLEDTaskbarTransparency，将数值数据设置为1到9的数值，这里就设置为“1”了，并点击确定退出，然后重启电脑后就可以看到透明度变化了</p><p>UseOLEDTaskbarTransparency数值1-9的透明度不一样，可自行测试，这是微软自带的更改透明度方式，想要达到全透明必须借助软件，以下推荐 ** TranslucentTB</p><p>个人建议win10自带应用商店下载即可，win10商店自带中文版，英文不好可选中文版</p><p>软件下载完成直接运行即可立刻达到任务栏全透明，然后又出现了一个新问题，退出软件任务栏就恢复了，不退出会在系统托盘有图标，作为强迫症患者，你可以占用小，可以后台运行，但是不能让我看到。因为以下介绍隐藏系统托盘图标的方式</p><h1 id="隐藏系统托盘图标"><a href="#隐藏系统托盘图标" class="headerlink" title="隐藏系统托盘图标"></a>隐藏系统托盘图标</h1><p>原理介绍：<br>程序向系统托盘加入图标,就一定要调用SHELL32.Shell_NotifyIconA函数，以下是API原形：<br>Declare Function Shell_NotifyIcon Lib “shell32.dll” Alias “Shell_NotifyIconA” (ByVal dwMessage As Long, lpData As NOTIFYICONDATA) As Long<br>Const NIF_ICON = &amp;H2<br>Const NIF_TIP = &amp;H4<br>Const NIM_ADD = &amp;H0      //这个就是向托盘加入图标的参数<br>Const NIF_MESSAGE = &amp;H1<br>Const NIM_MODIFY = &amp;H1<br>Const NIM_Delete = &amp;H2     //这个就是从托盘中删除图标的参数</p><p>这个函数有两个参数，其中一个是控制是否显示图标在任务栏的。可以取3个值。<br>—-０（向任务栏添加图标）<br>—-１（修改任务栏中的图标）<br>—-２（删除任务栏中的图标）</p><p>因此我们只需要把0改为2即可实现隐藏图标</p><p>由于程序是封装好的exe文件，我们想要更改只能借助新的工具：c32asm<br>c32asm是一款反汇编工具，支持中文。</p><p><img src="/2020/12/08/ren-wu-lan-quan-tou-ming-ji-yin-cang-xi-tong-tuo-pan-tu-biao/A20201208235803.png" alt></p><p>点击查看-输入表，找到SHELL32.DLL中的Shell_NotifyIconW函数，把PUSH的HEX值改为2，这里都是16进制的。</p><p><img src="/2020/12/08/ren-wu-lan-quan-tou-ming-ji-yin-cang-xi-tong-tuo-pan-tu-biao/B20201209000403.png" alt></p><p>保存，然后重新运行系统托盘就没有图标了。</p><p>c32asm下载百度云地址：链接：<a href="https://pan.baidu.com/s/1EhEMTTF0e_cD-LB0I5QZVA" target="_blank" rel="noopener">https://pan.baidu.com/s/1EhEMTTF0e_cD-LB0I5QZVA</a><br>提取码：l3cl<br>更改好的TranslucentTB百度云地址：链接：<a href="https://pan.baidu.com/s/1lZAU0BWAB0YRCuHXiqhvSw" target="_blank" rel="noopener">https://pan.baidu.com/s/1lZAU0BWAB0YRCuHXiqhvSw</a><br>提取码：6toa </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Centos8开启BBR</title>
      <link href="2020/11/04/centos8-kai-qi-bbr/"/>
      <url>2020/11/04/centos8-kai-qi-bbr/</url>
      
        <content type="html"><![CDATA[<p>Cenos8现在网上的锐速脚本还很少，因此安装锐速换内核很麻烦<br>但是BBR系统内核已经支持了，不需要安装</p><p>因此安装BBR的步骤就非常简单</p><p>打开这个文件 /etc/sysctl.conf，加入下边两句话</p><blockquote><p>net.core.default_qdisc = fq<br>net.ipv4.tcp_congestion_control = bbr</p></blockquote><p>保存退出，执行下面的命令使配置生效</p><blockquote><p>sysctl -p</p></blockquote><p>至此BBR就成功开启了<br>可以通过以下三条命令检查是否开启成功</p><blockquote><p>[root@centos8-1 ~]# sysctl net.ipv4.tcp_available_congestion_control<br>net.ipv4.tcp_available_congestion_control = reno cubic bbr</p></blockquote><blockquote><p>[root@centos8-1 ~]# sysctl net.ipv4.tcp_congestion_control<br>net.ipv4.tcp_congestion_control = bbr</p></blockquote><blockquote><p>[root@centos8-1 ~]# lsmod | grep bbr<br>tcp_bbr                20480  1</p></blockquote><p>三条命令输出都有bbr就是成功了，实际工作上一般都只执行最后一条检测</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自用程序</title>
      <link href="2020/10/31/zi-yong-cheng-xu/"/>
      <url>2020/10/31/zi-yong-cheng-xu/</url>
      
        <content type="html"><![CDATA[<h3 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h3><p><a href="/download/remote.bat">点击下载</a></p><h3 id="TCPServer"><a href="#TCPServer" class="headerlink" title="TCPServer"></a>TCPServer</h3><p><a href="/download/TCPServer.zip">点击下载</a></p><h3 id="ShadowsocksR-win-4-9-0-zip"><a href="#ShadowsocksR-win-4-9-0-zip" class="headerlink" title="ShadowsocksR-win-4.9.0.zip"></a>ShadowsocksR-win-4.9.0.zip</h3><p><a href="/download/ShadowsocksR-win-4.9.0.zip">点击下载</a></p><h3 id="站群脚本"><a href="#站群脚本" class="headerlink" title="站群脚本"></a>站群脚本</h3><p><a href="/download/ip.cmd">点击下载</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux服务器被DDoS或CC攻击时如何封禁攻击者IP</title>
      <link href="2020/06/05/linux-fu-wu-qi-bei-ddos-huo-cc-gong-ji-shi-ru-he-feng-jin-gong-ji-zhe-ip/"/>
      <url>2020/06/05/linux-fu-wu-qi-bei-ddos-huo-cc-gong-ji-shi-ru-he-feng-jin-gong-ji-zhe-ip/</url>
      
        <content type="html"><![CDATA[<p>Linux服务器就是采用Linux系统的网络服务器，当Linux服务器遭到DDOS攻击或者CC攻击时，如果攻击流量非常大，那只能通过专业的网络安全公司接入高防来防御了，但如果是小流量的攻击时，我们可以通过使用 iptables 来手动封禁这些攻击者的IP，从而达到防护效果。今天就来分享一下Linux服务器下如何获取攻击者IP然后进行封禁。</p><p>通过 netstat 获取攻击者 IP</p><p>如果攻击者攻击的是你的 Web 服务的话，默认是80端口，我们就可以使用下面的代码，如果攻击的不是80端口的话，将下面的两个数字80改为你被攻击的端口即可。如果你需要显示多条记录，请自己手动将head -n20调大即可。</p><p>netstat -anlp|grep 80|grep tcp|awk ‘{print $5}’|awk -F: ‘{print $1}’|sort|uniq -c|sort -nr|head -n20 | netstat -ant |awk ‘/:80/{split($5,ip,”:”);++A[ip[1]]}END{for(i in A) print A,i}’ |sort -rn|head -n20</p><p>通过 tcpdump 获取攻击者 IP</p><p>在使用之前，请确保您的系统已经安装了tcpdump，Debian/Ubuntu系列快速安装如下：</p><p>apt-get install -y tcpdump</p><p>安装后，使用下面的代码即可。需要注意的是，-i eth0指的是你主网卡，如果你是 OpenVZ 的虚拟机的话，就改成您的网卡名venet0。同样你需要设置的是，port 80设置你被攻击的端口，-c 1000指 tcpdump 需要统计的记录数，他会在达到这个数之后显示结果。head -20设置你要显示的记录条数。</p><p>tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F”.” ‘{print $1″.”$2″.”$3″.”$4}’ | sort | uniq -c | sort -nr |head -20</p><p>如何封禁 IP ？</p><p>通过上面的步骤，我们已经知道是谁在攻击我们了，现在我们就可以将他们拉入iptables禁止他们连接到服务器了。</p><p>封禁单个 IP<br>iptables -I INPUT -s 211.1.2.1 -j DROP</p><p>封禁一个 IP 段<br>iptables -I INPUT -s 211.1.2.0/16 -j DROP</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微信自动回复机器人</title>
      <link href="2020/06/04/wei-xin-zi-dong-hui-fu-ji-qi-ren/"/>
      <url>2020/06/04/wei-xin-zi-dong-hui-fu-ji-qi-ren/</url>
      
        <content type="html"><![CDATA[<p>通过itchat获取微信的相关消息，将微信消息传输到青云客机器人接口，获取机器人的返回消息。将返回消息返回给微信消息的发送人。以此实现将微信个人号变身为聊天机器人。</p><p>因为图灵机器人现在需要实名认证，并每天免费数量只有100条，感觉非常麻烦，所以找了一个免费的接口-<a href="http://api.qingyunke.com/" target="_blank" rel="noopener">青云客</a>，虽然这个智能程度没有图灵机器人那么高，但是也足够应付基本的消息了，不过有时候有点智障，谨慎使用哈。</p><p>以下是接口说明：</p><p><img src="/2020/06/04/wei-xin-zi-dong-hui-fu-ji-qi-ren/5d1df6fdad7a558919.png" alt></p><blockquote><p>安装库</p></blockquote><p>需要安装以下python库才能够跑起来</p><ul><li>itchat</li><li>requests</li></ul><blockquote><p>具体代码</p></blockquote><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><h1 id="Time-2019-7-3-14-23"><a href="#Time-2019-7-3-14-23" class="headerlink" title="@Time    : 2019/7/3 14:23"></a>@Time    : 2019/7/3 14:23</h1><h1 id="Author-donlex"><a href="#Author-donlex" class="headerlink" title="@Author  : donlex"></a>@Author  : donlex</h1><h1 id="Email-donlex-qq-com"><a href="#Email-donlex-qq-com" class="headerlink" title="@Email   : donlex@qq.com"></a>@Email   : <a href="mailto:donlex@qq.com">donlex@qq.com</a></h1><h1 id="Software-PyCharm-2018-1-4-Professional-Edition"><a href="#Software-PyCharm-2018-1-4-Professional-Edition" class="headerlink" title="@Software: PyCharm 2018.1.4 (Professional Edition)"></a>@Software: PyCharm 2018.1.4 (Professional Edition)</h1><p>import itchat<br>import requests</p><p>def get_response(msg):<br>    apiUrl = ‘<a href="http://api.qingyunke.com/api.php?key=free&amp;appid=0&amp;msg={}&#39;.format" target="_blank" rel="noopener">http://api.qingyunke.com/api.php?key=free&amp;appid=0&amp;msg={}&#39;.format</a>(<br>        msg)<br>    # 发送post请求<br>    r = requests.post(apiUrl).json()<br>    # 替换br字符串<br>    response = r.get(‘content’).replace(‘{br}’, ‘\n’)<br>    return response</p><h1 id="用于接收来自朋友间的对话消息"><a href="#用于接收来自朋友间的对话消息" class="headerlink" title="用于接收来自朋友间的对话消息"></a>用于接收来自朋友间的对话消息</h1><h1 id="如果不用这个，朋友发的消息便不会自动回复"><a href="#如果不用这个，朋友发的消息便不会自动回复" class="headerlink" title="如果不用这个，朋友发的消息便不会自动回复"></a>如果不用这个，朋友发的消息便不会自动回复</h1><p>@itchat.msg_register(itchat.content.TEXT)<br>def print_content(msg):<br>    return get_response(msg[‘Text’])</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    itchat.auto_login(True) #保存登录信息，下次不用扫码<br>    itchat.run()</p><blockquote><p>详细解释</p></blockquote><p>itchat.auto_login()是将会通过微信扫描二维码登录，但是这种登录的方式确实短时间的登录，并不会保留登录的状态，也就是下次登录时还是需要扫描二维码。</p><p>另外，扫码登录是通过网页版微信登陆，因为新注册的微信账号可能不支持网页版功能，所以最好是在使用之前，先验证下能够登录网页版微信。</p><blockquote><p>其他机器人</p></blockquote><ul><li>图灵机器人：<a href="http://www.turingapi.com/" target="_blank" rel="noopener">http://www.turingapi.com/</a> 需求实名制认证，并每天免费数量只有100条）</li><li>一个AI：<a href="http://www.yige.ai/（免费且无数量限制。可自定义回复、对话、场景。但高级功能使用比较复杂。但已长时间没人维护）" target="_blank" rel="noopener">http://www.yige.ai/（免费且无数量限制。可自定义回复、对话、场景。但高级功能使用比较复杂。但已长时间没人维护）</a></li><li>智能闲聊（腾讯）<a href="https://ai.qq.com/product/nlpchat.shtml" target="_blank" rel="noopener">https://ai.qq.com/product/nlpchat.shtml</a> ( 申请使用，免费且无限量。大厂靠谱。)</li><li>天行机器人 <a href="https://www.tianapi.com/apiview/47" target="_blank" rel="noopener">https://www.tianapi.com/apiview/47</a> (认证后有7万条免费使用。之后收费：1万条/1块钱)</li><li>海知智能 <a href="https://ruyi.ai/" target="_blank" rel="noopener">https://ruyi.ai/</a> （功能很强大，不仅仅用于聊天。需申请 key，免费）</li></ul><p>现在微信已禁止使用第三方机器人，可能会被封号</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>突破淘宝登录验证反爬</title>
      <link href="2020/06/04/tu-po-tao-bao-deng-lu-yan-zheng-fan-pa/"/>
      <url>2020/06/04/tu-po-tao-bao-deng-lu-yan-zheng-fan-pa/</url>
      
        <content type="html"><![CDATA[<p>淘宝登录的主要三种方式</p><ul><li>账号密码登录(有滑块)</li><li>微博第三方账号登录(无滑块)</li><li>扫码登录</li></ul><p>上面都是使用 Selenium 进行模拟登录的，这样就可以不用手动添加各种Cookie或者Session，少了很多工作。</p><p><strong>注：仅供技术交流使用，请不要用作其他用途！</strong></p><blockquote><p>淘宝账号登录</p></blockquote><p>一般直接使用Selenium自动控制登录，都会无法通过滑块验证。所以解决的策略就是让这些网站识别不出来你是用了Selenium，因此需要将模拟浏览器设置为开发者模式，这样就可以防止被网站识别出来。</p><p>只需要在初始化时，添加下面这条语句，就可以设置为开发者模式。</p><h1 id="此步骤很重要"><a href="#此步骤很重要" class="headerlink" title="此步骤很重要"></a>此步骤很重要</h1><p>options.add_experimental_option(‘excludeSwitches’[‘enable-automation’])</p><p>browser = webdriver.Chrome(options=options)</p><p>只需要多加一行代码，就能突破淘宝登录滑块，效果如下：</p><p><img src="/2020/06/04/tu-po-tao-bao-deng-lu-yan-zheng-fan-pa/5cc02db5ec2a0.gif" alt></p><p>当然这只是让Selenium通过淘宝的滑块验证而已，至于如何滑动还是需要自己动手撸代码才能实现真正的自动。。。</p><blockquote><p>微博账号登录</p></blockquote><p>在淘宝网的登录页面，有第三方登录的入口，试了一下，发现绑定微博的账号跟淘宝更配哦。直接通过Selenium控制，输入微博账号和密码，不需要滑块验证，不需要滑块验证，不需要滑块验证(重要的事情说**，直接就可以登录。</p><p><img src="/2020/06/04/tu-po-tao-bao-deng-lu-yan-zheng-fan-pa/5cc02db27e6db.gif" alt></p><blockquote><p>扫码登录</p></blockquote><p>还有一种方法：扫码登录，这种方式检测出是使用自动化工具，但是扫码登录能减去所有的验证环节，并且不需要写登录代码，只需要在扫码的页面停留几秒，等待手机淘宝扫码验证完成。接着就可以继续下面的工作了，不过这有一个缺点，就是不能设置不加载图片，如果设置了不加载图片的话，二维码就显示不了，就别谈登录了，这样一来，爬取的速度肯定会受到影响。</p><p>代码：</p><p>from time import sleep</p><p>from selenium import webdriver<br>driver = webdriver.Chrome()<br>driver.implicitly_wait(5)<br>def scan_login(url):<br>    driver.get(url)<br>    # 等待扫码登录<br>    sleep(15)<br>    # 进入之后开始其他操作</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    url = ‘<a href="https://login.taobao.com/member/login.jhtml&#39;" target="_blank" rel="noopener">https://login.taobao.com/member/login.jhtml&#39;</a><br>    scan_login(url)</p><p>效果：</p><p><img src="/2020/06/04/tu-po-tao-bao-deng-lu-yan-zheng-fan-pa/5cc02db6efca9.gif" alt></p><blockquote><p>最后</p></blockquote><p>个人感觉在需要突破登录部分的反爬措施，直接使用 Selenium 是最通用的，当然得看具体的情况。如果你正在练习登录这方面的爬虫，希望能够对你帮助！如果你有好的方法，也可以交流一下！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决CentOS启动docker失败</title>
      <link href="2020/06/04/jie-jue-centos-qi-dong-docker-shi-bai/"/>
      <url>2020/06/04/jie-jue-centos-qi-dong-docker-shi-bai/</url>
      
        <content type="html"><![CDATA[<blockquote><p>解决CentOS启动docker失败</p></blockquote><p>安装了Docker之后，使用命令启动却失败。</p><p>报错：</p><p><code>Job for docker.service failed because the control process exited with error code. See “systemctl status docker.service” and “journalctl -xe” for details.</code></p><p>按照提示：<code>systemctl status docker.service</code>，看到的日志信息：</p><p><img src="/2020/06/04/jie-jue-centos-qi-dong-docker-shi-bai/5c56ad5dd084c.png" alt></p><p>看了几篇博客都没有解决，最终找到解决办法：是由于docker不支持图像内核驱动，SELinux不支持这个内核上的OrthALA2图形驱动程序。解决办法：修改docker配置文件：</p><p><code>vi  /etc/sysconfig/docker</code></p><p>把OPTIONS一行改为：</p><p><code>OPTIONS=&#39;--selinux-enabled=false --log-driver=journald --signature-verification=false&#39;</code></p><p>按下“Esc”，输入“：”加“wq”保存退出vim编辑模式，再启动：</p><p><code>service docker start</code></p><p>就解决了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>web项目中使用支付宝接口</title>
      <link href="2020/06/04/web-xiang-mu-zhong-shi-yong-zhi-fu-bao-jie-kou/"/>
      <url>2020/06/04/web-xiang-mu-zhong-shi-yong-zhi-fu-bao-jie-kou/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言</p></blockquote><p>一直想弄一个有关于支付的第三方接口调用的web项目，网上看了一大堆资料，最后还是选择了使用支付宝。原因有一下两点：</p><ul><li>不用另外注册账户(一直讨厌注册各种账户)</li><li>支付宝有沙箱功能，可以实现虚拟支付，适合拿来练手</li></ul><p>下面就进入正题吧</p><blockquote><p>进入沙箱</p></blockquote><p>支付宝扫码登录蚂蚁金服开放平台之后，在首页的常用功能那里进入沙箱应用，如果是第一次使用，就需要添加功能。参考下图</p><p><img src="/2020/06/04/web-xiang-mu-zhong-shi-yong-zhi-fu-bao-jie-kou/5bceeddeecc05.png" alt></p><blockquote><p>生成RSA密钥</p></blockquote><p>进入沙箱应用之后可以看到信息配置部分需要设置RSA2(SHA256)密钥，由于我已经设置过了，这里就没有相应的截图。</p><p>生成RSA密钥的工具官方也提供了，直接查看生成RSA密钥进入下载工具，并按照步骤就可以生成密钥了</p><blockquote><p>上传密钥</p></blockquote><p>通过上一步生成的密钥，直接在沙箱应用中上传，如果验证通过的话，就可以开始接入代码了。</p><p><img src="/2020/06/04/web-xiang-mu-zhong-shi-yong-zhi-fu-bao-jie-kou/5bceede57b2a9.png" alt></p><blockquote><p>下载demo</p></blockquote><p>在官网中下载demo：<a href="https://docs.open.alipay.com/270/106291/" target="_blank" rel="noopener">https://docs.open.alipay.com/270/106291/</a> ,将demo解压。然后下载沙箱版的支付宝(只支持安卓版)，然后回到沙箱环境中，查看沙箱账号，用买家信息登录。</p><p><img src="/2020/06/04/web-xiang-mu-zhong-shi-yong-zhi-fu-bao-jie-kou/5bceede851d01.png" alt></p><blockquote><p>合并入自己的项目</p></blockquote><p>下面就以一个简单的例子开始，具体步骤如下：</p><ul><li>将解压文件中的jar包放入项目lib中,把 jsp文件 或者自己写的页面复制入项目，</li><li>修改AlipayConfig文件的部分配置</li><li>编写简单的servlet</li><li>运行查看支付</li></ul><p>详细的目录结构如下：</p><p><img src="/2020/06/04/web-xiang-mu-zhong-shi-yong-zhi-fu-bao-jie-kou/5bceede9e4a47.png" alt></p><p>AlipayConfig:</p><p>public class AlipayConfig {</p><p>//↓↓↓↓↓↓↓↓↓↓请在这里配置您的基本信息↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</p><pre><code>// 应用ID,您的APPID，收款账号既是您的APPID对应支付宝账号public static String app_id = &quot;填入沙箱APPID&quot;;// 商户私钥，您的PKCS8格式RSA2私钥public static String merchant_private_key = &quot;填入你的密钥&quot;;// 支付宝公钥,查看地址：https://openhome.alipay.com/platform/keyManage.htm 对应APPID下的支付宝公钥。public static String alipay_public_key = &quot;填入公钥&quot;;// 服务器异步通知页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问public static String notify_url = &quot;http://localhost:8080/alipay.trade.page.pay-JAVA-UTF-8/notify_url.jsp&quot;;// 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问public static String return_url = &quot;http://localhost:8080/alipay.trade.page.pay-JAVA-UTF-8/return_url.jsp&quot;;// 签名方式public static String sign_type = &quot;RSA2&quot;;// 字符编码格式public static String charset = &quot;utf-8&quot;;// 支付宝网关public static String gatewayUrl = &quot;https://openapi.alipaydev.com/gateway.do&quot;;// 支付宝网关public static String log_path = &quot;C:\\&quot;;</code></pre><p><strong>servlet代码:</strong></p><p>这里写了一个简单的doGet方法，当请求这个servlet的时候就会执行支付，然后使用沙箱版的支付宝直接扫码或者网页登录沙箱应用账号就可以支付了</p><p>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br>        //获得初始化的AlipayClient<br>        AlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.gatewayUrl, AlipayConfig.app_id, AlipayConfig.merchant_private_key, “json”, AlipayConfig.charset, AlipayConfig.alipay_public_key, AlipayConfig.sign_type);<br>      //设置请求参数<br>        AlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest();<br>        alipayRequest.setReturnUrl(AlipayConfig.return_url);<br>        alipayRequest.setNotifyUrl(AlipayConfig.notify_url);</p><pre><code>    //商户订单号，商户网站订单系统中唯一订单号，必填    String out_trade_no = &quot;20181037&quot;;    //付款金额，必填    String total_amount = &quot;9999&quot;;    //订单名称，必填    String subject = &quot;支付宝测试&quot;;    //商品描述，可空    String body = &quot;商品描述&quot;;    alipayRequest.setBizContent(&quot;{\&quot;out_trade_no\&quot;:\&quot;&quot;+ out_trade_no +&quot;\&quot;,&quot;             + &quot;\&quot;total_amount\&quot;:\&quot;&quot;+ total_amount +&quot;\&quot;,&quot;             + &quot;\&quot;subject\&quot;:\&quot;&quot;+ subject +&quot;\&quot;,&quot;             + &quot;\&quot;body\&quot;:\&quot;&quot;+ body +&quot;\&quot;,&quot;             + &quot;\&quot;product_code\&quot;:\&quot;FAST_INSTANT_TRADE_PAY\&quot;}&quot;);    //请求    String result;    try {        result = alipayClient.pageExecute(alipayRequest).getBody();        response.setContentType(&quot;text/html;charset=&quot; + AlipayConfig.charset);        response.getWriter().write(result);//直接将完整的表单html输出到页面        response.getWriter().flush();        response.getWriter().close();    } catch (AlipayApiException e) {        e.printStackTrace();        response.getWriter().write(&quot;捕获异常出错&quot;);        response.getWriter().flush();        response.getWriter().close();    }}</code></pre><p>效果：</p><p><img src="/2020/06/04/web-xiang-mu-zhong-shi-yong-zhi-fu-bao-jie-kou/5bceedec3b1e1.png" alt></p><p>这时候直接使用沙箱版扫码支付就可以了<br>从此不用担心的问题，随心所欲，不用家里有矿也有花不完的钱！！！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解除Dr.com的WiFi限制，开启热点</title>
      <link href="2020/06/04/jie-chu-dr-com-de-wifi-xian-zhi-kai-qi-re-dian/"/>
      <url>2020/06/04/jie-chu-dr-com-de-wifi-xian-zhi-kai-qi-re-dian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言</p></blockquote><p>现在国内大部分高校都使用了宽带上网认证，有一些比较严格的客户端还会禁止开启WiFi共享。</p><p>下面就来记录一下，在Dr.com客户端下破解共享限制的功能，实现WiFi共享上网冲浪。</p><blockquote><p>解除WiFi限制</p></blockquote><p>在校园网中使用Dr.com连接的用户，如果检测到存在共享行为，就会迫使账户下线；所以为了能够解除WiFi限制，需要安装一个插件才可以使Dr.com客户端跳过检测WiFi共享的行为。</p><p><a href="https://download.csdn.net/download/stormdony/10707210" target="_blank" rel="noopener">破解WiFi限制，点击下载插件</a></p><p>下载工具包之后，直接运行该软件，然后点击 破解Dr.com 即可，破解WiFi限制；</p><p><img src="/2020/06/04/jie-chu-dr-com-de-wifi-xian-zhi-kai-qi-re-dian/5bbc159d17bc9.png" alt></p><p>破解后校园网可以随意使用猎豹WiFi、360随身wifi共享网络，也能使用win10自带的热点功能建立热点。</p><p>如果是使用猎豹WiFi开启热点的话，手机挂VP(屁)N(恩)是翻不过去的。但是如果是Win10自带的工具，就可以科学上网。具体原因尚未找到 :(</p><blockquote><p>使用命令开启WiFi</p></blockquote><ul><li>首先开启wifi需要管理员权限，所以在开始菜单搜索cmd或组合键win+r，右键以管理员身份运行。</li><li>输入netsh wlan set hostednetwork mode=allow 回车，把承载网络模式设置为允许</li><li>输入netsh wlan set hostednetwork ssid=无线网络的名称 key=您想要设置的密码<blockquote><p>名称跟密码直接写就行，不用双引号什么的<br>ssid跟key用空格隔开<br>密码必须8位以上</p></blockquote></li><li>输入netsh wlan start hostednetwork<br>回车开启wifi</li><li>这时候虽然开启了wifi，但是还是这时候还是无互联网连接的，所以需要有网络的网络连接共享给它</li><li>进入<strong>控制面板\所有控制面板项\网络和共享中心</strong>选择已经连接上互联网的网络，设置允许其他用户共享网络；具体步骤参考下图<br><img src="/2020/06/04/jie-chu-dr-com-de-wifi-xian-zhi-kai-qi-re-dian/5bbc15d2e9f52.png" alt></li></ul><blockquote><p>其他命令</p></blockquote><p>#删除共享网络<br><code>netsh wlan set hostednetwork mode=disallow</code></p><h1 id="查看共享网络信息—蹭网信息"><a href="#查看共享网络信息—蹭网信息" class="headerlink" title="查看共享网络信息—蹭网信息"></a>查看共享网络信息—蹭网信息</h1><p><code>netsh wlan show hostednetwork</code></p><p>避免每次都要输入麻烦可以把这些命令做成批处理文件<br>新建文本保存以上代码，然后把文本文件改成<code>.bat</code>后缀，双击运行就可以了。</p><p>一般失败的话尝试以管理员身份运行</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo添加和取消live2d看板动画</title>
      <link href="2020/06/04/hexo-tian-jia-he-qu-xiao-live2d-kan-ban-dong-hua/"/>
      <url>2020/06/04/hexo-tian-jia-he-qu-xiao-live2d-kan-ban-dong-hua/</url>
      
        <content type="html"><![CDATA[<blockquote><p>添加看板娘</p></blockquote><p>在博客目录下安装依赖</p><p><code>npm install save hexo-helper-live2d</code></p><p>安装完就已经有默认看板娘了，不同主题是不是一样自行测试</p><p>在主题下的_config.yml的配置信息</p><p>Hexo的 _config.yml 文件添加配置.</p><p>live2d:<br>  enable: true<br>  scriptFrom: local<br>  pluginRootPath: live2dw/<br>  pluginJsPath: lib/<br>  pluginModelPath: assets/<br>  tagMode: false<br>  debug: false<br>  model:<br>    use: live2d-widget-model-wanko<br>  display:<br>    position: right<br>    width: 150<br>    height: 300<br>  mobile:<br>    show: false</p><p>使用其他的模型，需要先安装模型,在修改配置信息中的use</p><p>查看模型：<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">https://github.com/xiazeyu/live2d-widget-models</a></p><p>截图预览：<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">https://huaji8.top/post/live2d-plugin-2.0/</a></p><p>安装模型</p><p><code>npm install 模型的包名</code></p><p>具体可以查看官方文档：<a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</a></p><blockquote><p>取消看板娘</p></blockquote><p><code>npm uninstall hexo-helper-live2d</code></p><p>去掉站点_config.yml下的配置信息即可</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫利器-cURL转换</title>
      <link href="2020/06/04/pa-chong-li-qi-curl-zhuan-huan/"/>
      <url>2020/06/04/pa-chong-li-qi-curl-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言</p></blockquote><p>在爬虫的过程，经常需要为程序添加请求头，参数，cookie等信息，但是这些信息的添加都需要手动的去浏览器中找，然后一点一点的慢慢复制粘贴，这样效率就非常的低了。今天就分享一个网站，解决这些问题，让你脱离这些没有意义的劳动</p><blockquote><p>网站介绍</p></blockquote><p>网址: <a href="https://curl.trillworks.com" target="_blank" rel="noopener">https://curl.trillworks.com</a></p><blockquote><p>示范</p></blockquote><p><img src="/2020/06/04/pa-chong-li-qi-curl-zhuan-huan/5b909ad7cdda7.gif" alt></p><p>将需要爬取的请求复制curl到网站中转换，然后复制到pycharm中就可以直接爬取到整个网站的源码了，接下来就可以直接在这个基础上开始逻辑工作了</p><p>生成的代码：</p><p>import requests</p><p>cookies = {<br>    ‘_octo’: ‘GH1.1.681056136.1509806877’,<br>    ‘_gat’: ‘1’,<br>    ‘logged_in’: ‘no’,<br>    ‘_ga’: ‘GA1.2.70269906.1509806877’,<br>    ‘tz’: ‘Asia%2FShanghai’,<br>    ‘has_recent_activity’: ‘1’,<br>    ‘_gh_sess’: ‘cGpmdExmZUZpckZ0R1pSQlFxZlpsS2ZvT3NZbUU0YW1qTVloSzdFeWNxeWdNaGxsNzVveTJ3Vndrc2ZaN3ZoRDNYMm10TW9OdUdGVHhwbVRmMEU3ZWVwTUx4dUpZTUgrbHdKZkV0RnpzN3hodG12TGdLbHpSemVaQ0ZMM201MGdxMlkxdk5JNUZ6em1SWGp5ZEJUYTNQMjRFcCtqUDZaWVVFNXl3VDJRRUU4MFpqYkpvekY1VmZpY2t1R01ZcGRPQlZBUEJUOTJaWnNESjVnMnlkcncyWWhCVDl1OE5aVDhpR2Z4Z1NYVkFVNk5ReDRtTVphOXFXQWJNSVZYcnEyVktLTERLMHBTYjNwa2tUQUJaaWREQ0N4NzJYTG9sM1dpUktPaWFETFVpWGZlWFNvb2ZxazU1OUxMazVjZ3VNNTJteEdENzJPQlFKeDV3YXZCbmdHSGdGVmx5OVNjU2VaZXh3eEVwSlptczZXV3lQZXgrOGEyVGFwcUpPcFhIZTRWaDIwZExMRWhDRE8yMUdJT2xmS1grQ3I3bEYySGJvWFhNTFR3VmNpRnlLTT0tLXlRMmJZanl4Z0tUU0c0N1ZrRHpqbkE9PQ%3D%3D–1899440138004359a97b156d0ac8941135684ab5’,<br>}</p><p>headers = {<br>    ‘Accept-Encoding’: ‘gzip, deflate, sdch’,<br>    ‘Accept-Language’: ‘zh-CN,zh;q=0.8’,<br>    ‘Upgrade-Insecure-Requests’: ‘1’,<br>    ‘User-Agent’: ‘Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36’,<br>    ‘Accept’: ‘text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8’,<br>    ‘Referer’: ‘<a href="https://ghbtns.com/github-btn.html?user=NickCarneiro&amp;repo=curlconverter&amp;type=watch&amp;count=true&amp;size=large&#39;" target="_blank" rel="noopener">https://ghbtns.com/github-btn.html?user=NickCarneiro&amp;repo=curlconverter&amp;type=watch&amp;count=true&amp;size=large&#39;</a>,<br>    ‘Connection’: ‘keep-alive’,<br>    ‘Cache-Control’: ‘max-age=0’,<br>}</p><p>response = requests.get(‘<a href="https://github.com/NickCarneiro/curlconverter/&#39;" target="_blank" rel="noopener">https://github.com/NickCarneiro/curlconverter/&#39;</a>, headers=headers, cookies=cookies)</p><p>可以看到生成的代码非常的规整，是不是很方便~~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>歌词LRC、歌曲文件ID3标签与JAudiotagger</title>
      <link href="2020/06/04/ge-ci-lrc-ge-qu-wen-jian-id3-biao-qian-yu-jaudiotagger/"/>
      <url>2020/06/04/ge-ci-lrc-ge-qu-wen-jian-id3-biao-qian-yu-jaudiotagger/</url>
      
        <content type="html"><![CDATA[<p>现在的移动互联网时代，大部分人可能都不会刻意地留意关于歌曲的一些属性，直接在手机上下载或者在线听就行了。当然，这篇文章肯定会带你了解歌曲更加深入一点的内容，拓展一下知识面。</p><p>本文从两个方面进行探秘：</p><blockquote><blockquote><blockquote><p>歌词格式<br>歌曲文件</p></blockquote></blockquote></blockquote><blockquote><p>歌词</p></blockquote><p>首先，从歌词方面入手，这部分的知识也是我在爬取各音乐网站的时候发现的。</p><blockquote><blockquote><p>常见的歌词格式有 LRC、TRC（天天动听歌词）、KRC（KuGou ResourCe，酷狗资源文件）和 QRC（QQ音乐歌词)。</p></blockquote></blockquote><p>目前就通过爬虫测试发现大部分音乐网站都是使用LRC格式的歌词。</p><blockquote><p>LRC 格式</p></blockquote><p>LRC 歌词格式是世界上最通用的歌词格式，没有之一。它是最基本的歌词格式，几乎没有支持其他歌词格式而不支持这个歌词格式的播放器。LRC 歌词格式的特性也是——简单。</p><p><img src="/2020/06/04/ge-ci-lrc-ge-qu-wen-jian-id3-biao-qian-yu-jaudiotagger/20200604162634.png" alt></p><p>以上是一个示例LRC文件的开头部分.</p><p>可以看到，首先有一些记录歌曲及歌词信息的东东，我们将其称作“ID 标签”（ID Tags），它可以包含歌曲名（ti）、专集（al）、歌手（ar）、歌词创建者（by）、歌词延迟调整（offset）等信息。<br>一眼就可看出，LRC 格式为每行歌词指定起始时刻，格式为<strong>[分钟:秒.百分秒]。</strong></p><p>通过Postman请求QQ音乐可以发现，现在使用的也是这一种格式的歌词</p><p><img src="/2020/06/04/ge-ci-lrc-ge-qu-wen-jian-id3-biao-qian-yu-jaudiotagger/UcM67udAsTFK4CV.png" alt></p><blockquote><p>TRC格式<br>TRC 格式是由天天动听制定的一种歌词格式，可以看作是对 LRC 格式的扩展——为什么我这样说呢？请看下面我从一 TRC 文件中从头摘取的文本。</p></blockquote><p>[ar:胡彦斌]<br>[ti:当你要离开的时候]<br>[al:]<br>[total:243000]<br>[offset:0]<br>[by:ttpod]<br>[00:16.54]&lt;250&gt;当&lt;300&gt;你&lt;1852&gt;要&lt;249&gt;离&lt;452&gt;开&lt;201&gt;的&lt;451&gt;时&lt;3801&gt;候<br>[00:24.32]&lt;200&gt;我&lt;200&gt;们&lt;1201&gt;走&lt;250&gt;过&lt;250&gt;了&lt;251&gt;无&lt;350&gt;数&lt;350&gt;个&lt;600&gt;路&lt;3851&gt;口</p><p>因此，我们可以下结论，TRC 格式在 LRC 格式基础上，歌词正文中每个字的前面增加了时间标记&lt;毫秒数&gt;，每字连续解析，支持了逐字精准。或者，上文中“字”可理解为词，组合在一起当作一个“字”（以下称作“词看作字”），这在遇到英文时尤其有用。</p><p>当然，天天动听老黄历了，被阿里收购之后，现在也就无从探寻了。不过现在好像虾米音乐还是使用这种格式的歌词</p><p><img src="/2020/06/04/ge-ci-lrc-ge-qu-wen-jian-id3-biao-qian-yu-jaudiotagger/HZJw6ErPdgi3kDm.png" alt></p><blockquote><p>歌曲文件</p></blockquote><p>在电脑上下载一首歌曲，查看文件信息，会发现一个我们平常不留意的普通文件竟然会包含这么多的信息。</p><blockquote><p>ID3标签</p></blockquote><p>通过KMPlayer查看媒体信息可以看到以下信息，当然也包含了歌曲的封面图片<br><img src="/2020/06/04/ge-ci-lrc-ge-qu-wen-jian-id3-biao-qian-yu-jaudiotagger/g64x3R5UXFLbtC2.png" alt></p><p>其实这些信息都是通过在MP3文件末尾额外的数据空间来保存。说到这里就不得不说一下音频文件的ID3标签了</p><blockquote><blockquote><p>ID3，一般是位于一个mp3文件的开头或末尾的若干字节内，附加了关于该mp3的歌手，标题，专辑名称，年代，风格等信息，该信息就被称为ID3信息，ID3信息分为两个版本，v1和v2版。 其中：v1版的ID3在mp3文件的末尾128字节，以TAG三个字符开头，后面跟上歌曲信息。 v2版一般位于mp3的开头，可以存储歌词，该专辑的图片等大容量的信息. ——<a href="https://baike.baidu.com/item/ID3" target="_blank" rel="noopener">百度百科</a></p></blockquote></blockquote><blockquote><p>读写ID3标签</p></blockquote><p>既然知道了MP3文件中的信息是ID3标签，那我们能否自己通过代码读写ID3标签呢？当然是可以的。<br>主要通过使用 JAudiotagger 对MP3文件进行操作就可以完成。</p><blockquote><p>步骤</p></blockquote><p>一、Maven直接引入Jaudiotagger或者使用jar包</p><!-- https://mvnrepository.com/artifact/org/jaudiotagger --><dependency>    <groupId>org</groupId>    <artifactId>jaudiotagger</artifactId>    <version>2.0.3</version></dependency><p>二、使用代码操作<br>这里以Java实现了一个简单的例子：</p><pre><code>*设置ID3标签进入MP3文件中*copyrightInfoSave是一个实体*/public static void structAudioTag(CopyrightInfoSave copyrightInfoSave,String filePath,String lyricPath,String coverPath) throws Exception{    MP3File f = (MP3File) AudioFileIO.read(new File(filePath));    ID3v23Tag tag;    AbstractID3v2Tag tagV2=f.getID3v2Tag();    if(tagV2 instanceof ID3v23Tag){        tag=(ID3v23Tag)tagV2;    }else{        tag = new ID3v23Tag(tagV2);    }    tag.setField(FieldKey.ARTIST, copyrightInfoSave.getSingername());    tag.setField(FieldKey.ALBUM, copyrightInfoSave.getAlbumsname());    tag.setField(FieldKey.TITLE, copyrightInfoSave.getSongname());    tag.setField(FieldKey.COMMENT, &quot;&quot;);    String lyric = readToString(lyricPath);    tag.setField(FieldKey.LYRICS,lyric);    // 设置歌曲封面图片    tag.deleteArtworkField();    Artwork newArtwork=Artwork.createArtworkFromFile(new File(coverPath));    tag.setField(newArtwork);    tag.addField(newArtwork);    f.setID3v2Tag(tag);    f.save();}/***读取歌词文件，并返回string类型*/public static String readToString(String fileName) {    String encoding = &quot;UTF-8&quot;;    File file = new File(fileName);    Long filelength = file.length();    byte[] filecontent = new byte[filelength.intValue()];    try {        FileInputStream in = new FileInputStream(file);        in.read(filecontent);        in.close();        return new String(filecontent, encoding);    } catch (Exception e) {        e.printStackTrace();        return null;    }}</code></pre><p>}</p><p>更多例子查看<a href="http://www.jthink.net/jaudiotagger/examples.jsp" target="_blank" rel="noopener">官方的Example</a></p><blockquote><p>附</p></blockquote><p>参考资料：</p><ul><li><a href="http://blog.xieyc.com/mp3-music-messy-code-and-id3-tag/?kqfivm=adn5r2&lyvcja=bswmr2&vgzsli=dqi0e3" target="_blank" rel="noopener">MP3歌曲乱码和ID3标签</a></li><li><a href="https://shansing.com/read/392/" target="_blank" rel="noopener">初步分析 LRC、TRC、KRC、QRC、KSC 和 KAJ 歌词格式</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-plus的一些tips</title>
      <link href="2020/06/04/mybatis-plus-de-yi-xie-tips/"/>
      <url>2020/06/04/mybatis-plus-de-yi-xie-tips/</url>
      
        <content type="html"><![CDATA[<p>一些在使用springcloud和mybatis-plus中遇到的小问题以及解决方法</p><blockquote><p>oracle 列转行 LISTAGG和WM_CONCAT</p></blockquote><p>对于将一列多值合并成一行问题，oracle提供了wmsys.wm_concat和listagg函数处理此问题。但是使用那一个函数具体得看数据库的版本</p><blockquote><blockquote><p>WMSYS.WM_CONCAT: 依赖WMSYS用户<br>LISTAGG: 11g2才提供的函数，不支持distinct</p></blockquote></blockquote><p><code>select listagg(多行转单行的列,分隔符) within group(order by 按哪一列分组) from tmp t group by 按哪一列分组</code></p><p>用法就像聚合函数一样，通过Group by语句，把每个Group的一个字段，拼接起来，非常方便</p><p>例子：<br><code>select * from SONG_INFO ALBUMS_INFO</code></p><p>查出表的数据如图所示：<br><img src="/2020/06/04/mybatis-plus-de-yi-xie-tips/nAhLqk6B9bmQNCK.png" alt></p><p>现在我需要让两行中的名字合并成一行，并用“+”连接起来<br><code>select listagg(t.SONG_NAME, &#39;+&#39;) within group (order by t.SONG_RD) as BelongSinger</code><br><code>from (select * from SONG_INFO ALBUMS_INFO) t group by t.SONG_RD</code></p><p>结果：<br><img src="/2020/06/04/mybatis-plus-de-yi-xie-tips/Ik38DjeMcsbK5Ln.png" alt></p><blockquote><p>mybatis-plus使用枚举类型</p></blockquote><p>对于在代码中定义枚举类型，最好实现 IEnum 接口，并在配置文件中配置好扫描枚举类型的位置，否则会报下面的的错误。</p><p><code>java.lang.IllegalArgumentException: No enum constant com.content.enums.BusinessType.8</code><br><code>at java.lang.Enum.valueOf(Enum.java:238) ~[na:1.8.0_144]</code></p><p>配置文件设置为：<br><code>mybatis-plus.configuration.default-enum-type-handler=com.baomidou.mybatisplus.extension.handlers.MybatisEnumTypeHandler</code><br><code>mybatis-plus.type-enums-package=com.content.enums</code></p><p>具体可以参考：<a href="https://mp.baomidou.com/guide/enum.html" target="_blank" rel="noopener">mybatis-plus官网</a></p><blockquote><p>mybatis-plus关键字</p></blockquote><p>对于oracle中定义的实体名称和数据库中的关键字冲突，强烈建议不要使用关键字作为实体名称，因为自己使用注解@TableField，也不一定能够解决。<br>比如：我在使用validate这个关键字的时候，就无法正常的解释过去</p><p><img src="/2020/06/04/mybatis-plus-de-yi-xie-tips/KC8sJR327cUDSpM.png" alt></p><blockquote><p>oracle序列</p></blockquote><p>在java中使用update，并且主键是一个自增序列的话，如果另外有一个程序在批量导入数据，可能会导致休闲主键冲突的情况，这就是因为数据在导入的时候序列已经增长了，但是java代码还是使用自己原来每增长之前的序列，导致了冲突。</p><p>解决办法：</p><ul><li>先得到当前的序列</li><li>获取数据库中数据的id最大值</li><li>设置增长序列下一次增长为数据库中id最大值减去当前序列</li><li>运行一次获取下一序列值</li><li>设置序列下一次增长为1</li></ul><p><code>SELECT seq_t_test.CURRVAL FROM DUAL  -- 获取当前序列值</code><br><code>alter sequence seq_t_test increment by n -- n表示最大id值减去当前序列值</code><br><code>SELECT seq_t_test.NEXTVAL FROM DUAL -- 增长一次</code><br><code></code><br><code>alter sequence seq_t_test increment by 1 -- 设置回每次增长1</code><br><code>SELECT seq_t_test.CURRVAL FROM DUAL</code></p><blockquote><p>附</p></blockquote><p>参考资料：<br><a href="https://mp.baomidou.com/" target="_blank" rel="noopener">mybatis-plus官网</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>接口文档swagger-bootstrap-ui的使用</title>
      <link href="2020/06/04/jie-kou-wen-dang-swagger-bootstrap-ui-de-shi-yong/"/>
      <url>2020/06/04/jie-kou-wen-dang-swagger-bootstrap-ui-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>相信使用前后端分离的工程师都对接口文档折磨过。无论是前端调用后端，还是后端调用后端，都期望<br>有一个好的接口文档。而Swagger，我个人理解就是把相关的信息存储在它定义的描述文件里面（yml或<br>json格式），再通过维护这个描述文件可以去更新接口文档，以及生成各端代码，它能够很好地化解前<br>面所说的尴尬。</p><p>这样项目开始时期，只要前端跟后端定义好返回的数据格式，就可以根据接口文档进行统一的规范，这<br>样数据规范起来之后，前端就不需要等到后端开发好接口才能知道具体的数据格式，前端使用mockjs模<br>拟数据进行开发，大大节省了时间，同时也减少了不必要的沟通过程。</p><p>个人感觉原生的swagger-UI不太友好，所以在网上找到了swagger-bootstrap-ui，这是国人开发的ui包<br>，感觉非常不错。</p><blockquote><p>快速开始</p></blockquote><blockquote><p>引入maven包</p></blockquote><p>由于是springfox-swagger的增强UI包,所以基础功能依然依赖Swagger,springfox-swagger的jar包必须<br>引入</p><dependency> <groupId>io.springfox</groupId> <artifactId>springfox-swagger2</artifactId> <version>2.9.2</version></dependency><blockquote><p>然后引入SwaggerBootstrapUi的jar包</p></blockquote><dependency>  <groupId>com.github.xiaoymin</groupId>  <artifactId>swagger-bootstrap-ui</artifactId>  <version>1.9.6</version></dependency><p>当前最新的是1.9.6版本</p><blockquote><p>编写Swagger2Config配置文件</p></blockquote><p>Swagger2Config配置文件如下：</p><p>@Configuration<br>@EnableSwagger2<br>@EnableSwaggerBootstrapUI<br>public class SwaggerConfiguration {<br>    @Bean<br>    public Docket createRestApi() {<br>        return new Docket(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo())<br>                .select()<br>                .apis(RequestHandlerSelectors.withClassAnnotation(RestController.class))<br>                .paths(PathSelectors.any())<br>                .build();<br>    }<br><br>   \ private ApiInfo apiInfo() {<br>        \return new ApiInfoBuilder()<br>                .title(“接口文档”)<br>                .description(“接口文档”)<br>                .build();<br>    }<br>}</p><p>这里官网有一个对新手不太友好的小坑，那就是Docket中的apis中设置包的扫描路径，我之前是直接使<br>用官网的配置类，没有改变包的扫描路径，导致文档没有显示接口，而改成RequestHandlerSelectors.withClassAnnotation(RestController.class)之后就可以了，这样算是使用了软编码吧！</p><blockquote><p>访问地址</p></blockquote><p>swagger-bootstrap-ui默认访问地址是：http://${host}:${port}/doc.html</p><blockquote><p>swagger2注解</p></blockquote><p>给Controller类添加swagger2注解就生成相应的接口文档了。</p><p>例如:<br>@Api(value=”/test1”, tags=”测试接口模块”)<br>@RestController<br>public class testContro {<br>    @ApiOperation(“test”)<br>    @GetMapping(“/ha”)<br>    public String test(){<br>        return “test成功”;<br>    }<br>    @ApiOperation(“Area删除”)<br>    @GetMapping(“/a”)<br>    public String ha(){<br>        return “Area删除成功”;<br>    }<br>}</p><p>运行项目之后就可以看到下面的效果：<br><img src="/2020/06/04/jie-kou-wen-dang-swagger-bootstrap-ui-de-shi-yong/6OdusG7zl5SP4gC.png" alt="效果"></p><blockquote><p>最后</p></blockquote><p>有了接口文档之后，当前后端分离开发的时候，只需要丢一个测试环境的文档地址过去给前端就可以了<br>，直接看着文档进行参数对接，同时这个接口文档的调试功能也是非常不错的，有时候懒得写单元测试<br>，直接写一个查询的方法获取数据，再调用请求接口进行调试也是非常方便的。</p><blockquote><p>附</p></blockquote><p><a href="https://github.com/xiaoymin/Swagger-Bootstrap-UI" target="_blank" rel="noopener">swagger-bootstrap-ui 地址</a><br><a href="http://swagger-bootstrap-ui.xiaominfo.com/doc.html" target="_blank" rel="noopener">在线效果体验</a><br><a href="https://www.xiaominfo.com/2018/08/29/swagger-bootstrap-ui-description/" target="_blank" rel="noopener">swagger-bootstrap-ui详解</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus中调用Oracle存储过程</title>
      <link href="2020/06/03/mybatisplus-zhong-diao-yong-oracle-cun-chu/"/>
      <url>2020/06/03/mybatisplus-zhong-diao-yong-oracle-cun-chu/</url>
      
        <content type="html"><![CDATA[<p><strong>起因</strong></p><p>由于需要将新数据同步到另外的数据库，所以需要使用dblink进行操作，但是dblink不支持写入操作，因此需要调用写好的存储过程才能实现将新数据插入新数据的同时插入旧数据库。<br><strong>准备工作</strong></p><p>预先准备好新旧两个数据库<br><strong>旧的数据库</strong></p><blockquote><p>create table OLD_USER<br>(<br>  USER_ID                    NUMBER(6) not null primary key,<br>  LOGIN_NAME                 VARCHAR2(100) not null,<br>  REAL_NAME                  VARCHAR2(300),<br>  PASSWORD                   CHAR(64)<br>)</p></blockquote><p><strong>新的数据库</strong></p><blockquote><p>create table NEW_USER<br>(<br>  ID            NUMBER(11) not null primary key,<br>  CREATE_TIME   TIMESTAMP(6),<br>  UPDATE_TIME   TIMESTAMP(6),<br>  DELETED       NUMBER(1),<br>  ACCOUNT       VARCHAR2(255),<br>  USERNAME      VARCHAR2(255),<br>  PASSWORD      VARCHAR2(255)<br>)</p></blockquote><p>对应的实体为</p><blockquote><p>package com.donlex.demo.entity;</p><p>import com.baomidou.mybatisplus.annotation.FieldFill;<br>import com.baomidou.mybatisplus.annotation.KeySequence;<br>import com.baomidou.mybatisplus.annotation.TableField;<br>import io.swagger.annotations.ApiModel;<br>import io.swagger.annotations.ApiModelProperty;<br>import lombok.EqualsAndHashCode;<br>import lombok.Getter;<br>import lombok.Setter;<br>import lombok.ToString;</p><p>import java.util.Date;<br>import java.util.List;</p><p>@Getter<br>@Setter<br>@ToString(callSuper = true)<br>@EqualsAndHashCode(callSuper = true)<br>@ApiModel(“新数据库对应实体”)<br>@KeySequence(“s_old_user”)<br>public class NewUser {<br>   @ApiModelProperty(“主键”)<br>   @TableId(type = IdType.INPUT)<br>   private Long id;</p><p>   @ApiModelProperty(value = “创建时间”, hidden = true)<br>   @TableField(fill = FieldFill.INSERT)<br>   private Date createTime;</p><p>   @ApiModelProperty(value = “更新时间”, hidden = true)<br>    @TableField(fill = FieldFill.INSERT_UPDATE)<br>    private Date updateTime;</p><p>   @ApiModelProperty(value = “删除标志”, hidden = true)<br>    @TableField(fill = FieldFill.INSERT)<br>    @TableLogic<br>    private Boolean deleted;</p><p>   @ApiModelProperty(“用户账号”)<br>    private String account;</p><p>   @ApiModelProperty(“用户名称”)<br>    private String username;</p><p>   @ApiModelProperty(“密码”)<br>    private String password;</p><p>   @ApiModelProperty(“插入旧数据库返回的id”)<br>    @TableField(exist = false)<br>    private Integer oldUserId;<br>}</p></blockquote><p><strong>创建存储过程</strong></p><p>创建一个存储过程用于将新数据库的数据字段和旧的数据库字段映射上，同时使用序列自增作为id值，将新数据插入旧数据库中。</p><blockquote><p>create or replace procedure PRO_TO_OLD_USER(<br>                                        v_account in varchar2,<br>                                        v_username in varchar2,<br>                                        v_password in varchar2,<br>                                        v_result out varchar2) is</p><p> V_ID number;<br> PRAGMA AUTONOMOUS_TRANSACTION;<br>begin<br>– 使用序列自增做为主键，s_old_user为序列名， @dklinkName 是dblink名<br> SELECT s_old_user.NEXTVAL @dklinkName into V_ID FROM DUAL;<br> insert into OLD_USER(USER_ID,<br>                       LOGIN_NAME,<br>                       REAL_NAME,<br>                       PASSWORD<br>                     )<br> VALUES (V_ID,<br>– 使用case进行判断 v_account 字段是否为空<br>         case when v_account is null<br>                then<br>                ‘空’<br>              else<br>                v_account<br>         end,<br>         v_username,<br>         v_password<br>       );<br> commit;<br>– 返回自增的序列值<br> v_result := V_ID;<br> DBMS_OUTPUT.put_line(‘添加到旧数据库账号成功ID为’ || V_ID);</p><p>end PRO_TO_OLD_USER;</p></blockquote><p><strong>创建mapper中的方法</strong></p><blockquote><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “<a href="http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;" target="_blank" rel="noopener">http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</a><br>&lt;mapper namespace=”com.donlex.demo.mapper.NewUserMapper”&gt;<br>&lt;!– statementType 声明指向的是什么类型，其中CALLABLE是执行存储过程和函数的–&gt;<br>&lt;select id=”insertIntoOldUser” statementType=”CALLABLE” parameterType=”com.donlex.demo.entity.NewUser”&gt;<br>    {call PRO_TO_OLD_USER<br>         (<br>             #{account,mode=IN},<br>             #{username,mode=IN},<br>             #{password,mode=IN},<br>             #{oldUserId,mode=OUT,jdbcType=INTEGER}<br>         )<br>    }<br>  &lt;/select&gt;<br>&lt;/mapper&gt;</p></blockquote><p>注意点</p><ul><li>statementType 设置为 CALLABLE</li><li>在存储过程中使用参数时，除了写上必要的属性名外，还必须指定参数的 mode（模式），可选值为 IN、OUT、INOUT 三种，入参使用 IN，出参使用 OUT，输入输出参数使用 INOUT。</li><li>OUT 模式的参数，必须指定 <code>jdbcType</code>。因为在 IN 模式下，MyBatis 提供了默认的 jdbcType，在 OUT 模式下没有提供，因此必须指定 jdbcType</li><li>当入参存在无法识别，执行报错时，最好指定 jdbcType</li></ul><p><strong>创建mapper接口</strong></p><blockquote><p>@Mapper<br>@Repository<br>public interface NewUserMapper extends BaseMapper<NewUser> {<br>  /<em>*<br>  \</em><br>  * 将新数据新增的账号插入旧数据库<br>  * @author donlex<br>  * @param req<br>  */<br> void insertIntoOldUser(NewUser req);<br>}</NewUser></p></blockquote><p>这里定义的是<code>void</code>方法，但是实际上是会返回NewUser实体对象,所以可以通过get方法获取属性值，这就是为什么在实体中定义了一个oldUserId,但是它不是数据表中真实存在的字段 @TableField(exist = false)<br><strong>创建controller方法</strong></p><p>这里为了方便就直接在controller中写方法调用</p><blockquote><p>import lombok.extern.slf4j.Slf4j;</p><p>@Slf4j<br>@RestController<br>public class SysUserController {<br>    @Autowired<br>    private NewUserMapper newUserMapper;<br>    @ApiOperation(“将新数据写入旧数据库中”)<br>    @PostMapping(“/test”)<br>    public Boolean addNewUserToOldUser(NewUser newUser){<br>        newUserMapper.insertIntoNewUser(newsUser);<br>        log.info(“oldUserId为{}”,newUser.getOldUserId())<br>    }<br>}</p></blockquote><p>执行的debug日志</p><blockquote><p>2019-12-30 15:58:31.850 DEBUG  ==&gt;  Preparing: {call PRO_TO_OLD_USER ( ?, ?, ?, ? ) }<br>2019-12-30 15:58:31.885 DEBUG  ==&gt;  Parameters: 357869(String), donlex(String), a493fe7c29ce(String), 0(Integer)</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CentOS挂载lvm分区重名问题的解决方法</title>
      <link href="2020/06/01/centos-gua-zai-lvm-fen-qu-chong-ming-wen-ti-de-jie-jue-fang-fa/"/>
      <url>2020/06/01/centos-gua-zai-lvm-fen-qu-chong-ming-wen-ti-de-jie-jue-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>今天一个朋友的服务器硬盘出现问题，换了新硬盘安装好系统后，挂载老硬盘时出现了问题， 在linux下使用新硬盘安装系统，安装好以后再挂载原来的硬盘，分区格式全为系统默认分区，系统默认使用的<br>是lvm格式，并且默认的卷都是 VolGroup00，好了，知道问题的原因就好办了，下面我们来解决这个问题</p><p>使用 pvs 查看显示如下：</p><p>[root@localhost ~]# pvs<br>PV VG Fmt Attr PSize PFree<br>/dev/sda2 VolGroup00 lvm2 a- 372.50G 0<br>/dev/sdb2 VolGroup00 lvm2 a- 136.62G 0</p><p>发现可以正确认别到两个VG，但是同名，如何挂载呢？<br>解决办法是，将原来的VG更名，解决冲突即可挂载。</p><p>重命名格式为：vgrename VolGroup00 VolGroup01<br>此时会提示：<br>[root@localhost ~]# vgrename VolGroup00 VolGroup01<br>Found more than one VG called VolGroup00. Please supply VG uuid.</p><p>原因是存在两个 VolGroup00，修改的方法他已经提示了要指定 VG uuid即可。</p><p>查看VG uuid的命令为：</p><p>[root@localhost ~]# vgs -v<br>Finding all volume groups<br>Finding volume group “VolGroup00”<br>Finding volume group “VolGroup00”<br>VG Attr Ext #PV #LV #SN VSize VFree VG UUID<br>VolGroup00 wz–n- 32.00M 120372.50G 0 dcHa6G-abU2-Xfq8-EPBm-jBLj-sf18-O5uH0U<br>VolGroup00 wz–n- 32.00M 120136.62G 0 OF8g7h-PQJB-9D9z-yPxn-1kfY-Advq-YbNHJ9</p><p>查到VG uuid以后，再次执行改名：<br>[root@localhost ~]# vgrename OF8g7h-PQJB-9D9z-yPxn-1kfY-Advq-YbNHJ9 VolGroup01<br>Volume group “VolGroup00” still has active LVs</p><p>修改成功以后，再执行：lvscan</p><p>[root@localhost ~]# lvscan<br>inactive ‘/dev/VolGroup01/LogVol00’ [130.84 GB] inherit<br>inactive ‘/dev/VolGroup01/LogVol01’ [1.94 GB] inherit<br>ACTIVE ‘/dev/VolGroup00/LogVol00’ [367.09 GB] inherit<br>ACTIVE ‘/dev/VolGroup00/LogVol01’ [5.41 GB] inherit</p><p>可以看到新修改的VolGroup01是inactive状态。</p><p>再使用vgchange 加载 VolGroup01<br>[root@localhost ~]# vgchange -ay /dev/VolGroup01<br>2 logical volume(s) in volume group “VolGroup01” now active</p><p>再执行 ：lvscan<br>[root@localhost ~]# lvscan<br>ACTIVE ‘/dev/VolGroup01/LogVol00’ [134.69 GB] inherit<br>ACTIVE ‘/dev/VolGroup01/LogVol01’ [1.94 GB] inherit<br>ACTIVE ‘/dev/VolGroup00/LogVol00’ [367.09 GB] inherit<br>ACTIVE ‘/dev/VolGroup00/LogVol01’ [5.41 GB] inherit</p><p>可以发现VolGroup01已经是ACTIVE状态了。</p><p>最后 mount 就可以</p><p>[root@localhost ~]# mount /dev/VolGroup01/LogVol00 /data/www</p><p>至此，全部完成。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SSR安装</title>
      <link href="2020/06/01/ssr-an-zhuang/"/>
      <url>2020/06/01/ssr-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>这里介绍脚本安装方式，脚本已提前制作好，只需要按下面方式执行即可<br>1、wget –no-check-certificate -O shadowsocks-all.sh <a href="https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</a></p><p>新linux系统默认没有安装wget，如果报错先使用yum -y install wget安装再执行上面指令<br>或者使用管道符连接，直接使用下面指令<br>yum -y install wget &amp;&amp; wget –no-check-certificate -O shadowsocks-all.sh <a href="https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</a></p><p>2、赋予执行权限<br>chmod +x shadowsocks-all.sh</p><p>./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</p><p>3、输入你想要设置的VPN信息<br>密码，端口，加密信息。不输入就是默认，然后使用软件与脚本文章里提供的SSR软件连接。</p><p>附：SSR简单理解就是VPN，由于屏蔽原因有时候写成VPX<br>不能连接的排错方式：<br>1、更改端口，VPX的端口屏蔽很常见，遇到不能连接可以先更换端口<br>2、采用其他方式重新安装，例如第一次安装的是python版本，之后可以采用其他版本安装</p><p>加密信息一定要与设置的一直，不然解析回去的密码不相同也连接不上，我上传的是SSRR，会有混淆参数，协议参数等，这个脚本没有做这些，不填即可。自己下载shadowsocks也可以连接</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpeedTest网速测试工具</title>
      <link href="2020/06/01/speedtest-wang-su-ce-shi-gong-ju/"/>
      <url>2020/06/01/speedtest-wang-su-ce-shi-gong-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h1><p>speedtest 以 HTML 和 JavaScript 为主, 利用客户端的浏览器通过上传和下载垃圾数据来测试 HTTP 传输速度, 和大家常用的 speedtest.net 差不多.</p><p>speedtest 使用任意操作系统上的任意 Web 服务器作为服务端, 所以理论上它支持 Windows/MacOS/Linux/Unix 等系统, IIS/Nginx/Apache/lighttpd 等服务器.</p><p>任意浏览器作为客户端如 Chrome/Firefox/IE11/Edge/Safari/Opera?</p><p>speedtest 默认使用 PHP 作为服务端, 目前也有 node.js 版本, 也可以只用纯静态服务器.</p><p>本文所说的 speedtest 与 Ookla 公司的 speedtest.net 及相关测速 app 没有任何关系.</p><h1 id="搭建speedtest"><a href="#搭建speedtest" class="headerlink" title="搭建speedtest"></a>搭建speedtest</h1><p>[root@docker-01 ~]# yum install httpd php git -y</p><p>[root@docker-01 ~]# git clone <a href="https://github.com/adolfintel/speedtest.git" target="_blank" rel="noopener">https://github.com/adolfintel/speedtest.git</a></p><p>[root@docker-01 ~]# cd speedtest/</p><p>[root@docker-01 speedtest]# cp -R backend/ example-singleServer-pretty.html *.js /var/www/html/</p><p>[root@docker-01 html]# mv example-singleServer-pretty.html index.html</p><p>[root@docker-01 html]# chown -R apache *</p><p>[root@docker-01 html]# systemctl start httpd</p><p>访问自己IP即可测速</p><p>备注：在使用docker容器搭建SpeedTest时，创建容器指令之后需要添加需要加参数privileged=true同时/usr/sbin/init<br>用-d创建，在使用docker exec -it c1 /bin/bash </p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
